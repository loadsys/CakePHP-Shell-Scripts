#!/usr/bin/env bash

#---------------------------------------------------------------------
usage ()
{
	cat <<EOT

${0##*/}
    Designed to perform all the necessary steps to update a local 
    copy of the project from the remote repo, which is assumed to 
    be "ahead" of the local copy. Mainly intended for use in 
    staging and production environments to ensure that code "pushes" 
    are performed consistently every time. Should be run from the 
    project root folder.

Usage:
    bin/${0##*/} [tag|branch|sha|ref] [dev|prod|staging] [user] [group]

    \$1 = The new commit to update to. Default: 'origin/master'
    \$2 = The local config file "environment" to use. Default: $APP_ENV if set, 'prod' if not.
    \$3 = The local user to associate the project with. Default: owner of ./
    \$4 = The local group to associate the project with. Default: group of ./

Environment Variables:
          APP_ENV = If set and \$2 is blank, will be used as the active
                    environment for the update run.
    LOADSYS_EMAIL = If set, an email report for the update run will be
                    generated and sent to the email address contained within.

EOT

	exit 0
}
if [ "$1" = '-h' ]; then
	usage
fi


echo "## Starting update process."

# Set variables.
DIR="$( cd -P "$( dirname "$0" )"/.. >/dev/null 2>&1 && pwd )"
BIN_DIR="$DIR/bin"
CONFIG_DIR="$DIR/Config"
MIGRATION_DIR="$CONFIG_DIR/Migration"
SLEEP_TIME=10
DEFAULT_DBUPDATES_FILE="$CONFIG_DIR/sql/db_updates.sql"
DEFAULT_ENVVARS_FILE="$CONFIG_DIR/env_vars.txt"

if [ -d "$MIGRATION_DIR" ] && [ "$(ls -A $MIGRATION_DIR)" ]; then
	DB_UPDATES_METHOD='migrations'
elif [ -e "$DEFAULT_DBUPDATES_FILE" ]; then
	DB_UPDATES_METHOD='db_updates'
else
	DB_UPDATES_METHOD='none'
fi

if [ -r $DEFAULT_ENVVARS_FILE ]; then
	source "${DEFAULT_ENVVARS_FILE}"
fi


# Input processing.
if [ $1 ]; then
	ARG_NEWCOMMIT=$1
else
	#@TODO: This should really default to the remote tracked version of $EXISTINGBRANCH (which is currently set later), so that we can fast-forward on the same branch by default. So if $EXISTINGBRANCH is "master", then $ARG_NEWCOMMIT should (typically) be "origin/master".
	ARG_NEWCOMMIT="origin/master"
fi

if [ $2 ]; then
	ARG_APPENV="$2"
elif [ -n "$APP_ENV" ]; then
	ARG_APPENV="$APP_ENV"
else
	ARG_APPENV="prod"
fi

if [ $3 ]; then
	ARG_OWNER=$3
else
	ARG_OWNER=""
fi

if [ $4 ]; then
	ARG_GROUP=$4
else
	ARG_GROUP=""
fi


# Check for local changes that would cause a merge (without -f) to fail later.
$BIN_DIR/git-localchanges
if [ $? -gt 0 ]; then
	echo "!! You will need to resolve any differences between the working copy  !!"
	echo "!! and the active commit before proceeding with the update.           !!"
	echo ""
	exit 1
fi


# Backup the live DB.
$BIN_DIR/db-backup
echo ''
echo "## Sleeping for ${SLEEP_TIME} seconds to consider the backup size."
echo "##   (Press Ctrl-C to abort the update)..."
echo "##   (Press ENTER to continue immediately)..."
echo ''
read -t ${SLEEP_TIME} NOTUSED


# Save the "current" commit for later.
EXISTINGCOMMIT=$( git rev-parse HEAD )
EXISTINGBRANCH=$( git rev-parse --abbrev-ref HEAD )
echo "## Current commit is $EXISTINGBRANCH ($EXISTINGCOMMIT)";


# Update repository.
echo "## Pulling changes from remote repo.";

# @TODO: Investigate using a manual refspec to avoid two separate calls:
# Ref: http://stackoverflow.com/questions/1204190/does-git-fetch-tags-include-git-fetch#answer-14946840
# Example: git fetch origin refs/heads/*:refs/remotes/origin/* +refs/tags/*:refs/tags/*
#git fetch --tags

git fetch origin refs/heads/*:refs/remotes/origin/* +refs/tags/*:refs/tags/*


# Apply database updates, one way or another.
if [ "$DB_UPDATES_METHOD" = 'migrations' ]; then
	echo "## Deferring database migrations until after merge."
elif [ "$DB_UPDATES_METHOD" = 'db_updates' ]; then
	# Show manual pending DB updates to user. (Or use possibly use bin/db-apply-updates here to execute the SQL against the DB automatically, 
	# which should be fairly recoverable if it's wrong [which it can be] considering we have already made a backup.)
	DB_CHANGES="$( $BIN_DIR/db-show-updates $EXISTINGCOMMIT $ARG_NEWCOMMIT)"
	if [ -n "$DB_CHANGES" ]; then
		echo "## There are database updates to apply!"
		echo '---------'
		echo ''
		echo "$DB_CHANGES"
		echo ''
		echo '---------'
		echo ''
		read -p "Press [ENTER] to continue when these updates have been applied to the local DB."
	else
		echo "## No database updates to apply.";
	fi
elif [ "$DB_UPDATES_METHOD" = 'none' ]; then
	echo "## Could not automatically determine database change tracking system."
	read -p "## Make sure any pending DB changes have been made and press [ENTER] to continue."
fi


# This if case should really be looking to see if we're being asked to fast forward on the same branch, or switch to the HEAD of a different branch.
# if [ "$ARG_NEWCOMMIT" = "origin/master" ]; then
	echo "## Merging upstream changes from: $ARG_NEWCOMMIT";
	git merge $ARG_NEWCOMMIT
# else
# 	echo "## Checking out new commit: $ARG_NEWCOMMIT";
# 	git checkout $ARG_NEWCOMMIT
# fi


echo "## New commit is now active:";
GIT_LOG=$( git log -1 )
echo "${GIT_LOG}"


if [ "$DB_UPDATES_METHOD" = 'migrations' ]; then
	echo "## Applying database migrations."
	$BIN_DIR/migrations
fi

# Copy the correct config files into place for this environment.
$BIN_DIR/set-configs $ARG_APPENV


# Make sure any external packages are installed and available.
$BIN_DIR/deps-install


# Purge cache folders.
$BIN_DIR/clear-cache


# Set file ownership.
$BIN_DIR/set-owner ${ARG_OWNER} ${ARG_GROUP}


# Set write permissions.
$BIN_DIR/writedirs


# Send an email report if the ENV var is set in Config/env_vars.txt
if [ -n "${LOADSYS_EMAIL}" ]; then
	echo "## Generating email report."
	MSG_BODY=$( mktemp -t "${0##*/}.email_report.XXXXXXXXXX" )

	cat > "$MSG_BODY" <<-EOD
	A code push has been completed for ${LOADSYS_PROJECT_NAME}.

	${GIT_LOG}

	EOD

	bin/email "${LOADSYS_EMAIL}" "${LOADSYS_PROJECT_NAME}: Code push complete" "${MSG_BODY}"
	rm -f "${MSG_BODY}"
fi


echo "## Update process complete.";

