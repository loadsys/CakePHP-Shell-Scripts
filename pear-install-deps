#!/usr/bin/env bash

#---------------------------------------------------------------------
usage ()
{
	cat <<EOT

${0##*/}  
    Provides a shortcut syntax to discover multiple PEAR channels
    and install PEAR packages from them. Provide space-separated
    package names, optionally prefixed with their PEAR channel. If
    a channel is not provided, it is assumed it is already
    installed. For example:

    bin/pear-install-deps PHP_CodeSniffer pear.phpunit.de:phpunit/PHPUnit

    If no packages are supplied on the command line, a default
    config file is used that lists packages one per line. If that
    file is also not present or readable, the script exits with
    a non-zero status.

    Will exit non-zero if \`pear\` is not found in \$PATH.

Usage:
    bin/${0##*/} [[channel1:]package1 ...]


EOT

	exit 0
}
if [ "$1" = '-h' ]; then
	usage
fi

function get_channel_for_package() {
	for ARG in "${ARGS[@]}"; do
		ARG=${ARG/:$1}
		if ! [[ $ARG =~ ':' ]]; then  # If we stripped a colon, we have a match.
			CHANNEL=$ARG
			return 0
		fi
	done
	CHANNEL=''
	return 1
}

DIR="$( cd -P "$( dirname "$0" )"/.. >/dev/null 2>&1 && pwd )"
THIS_DIR="$( cd -P "$( dirname "$0" )"/. >/dev/null 2>&1 && pwd )"
PEAR_OPTIONS="--alldeps"
PEAR_PACKAGES_FILE="$DIR/Config/pear_packages.txt"

# Bail out if PEAR isn't available to us.
PEAR="$( which pear )"
if [ $? -gt 0 ]; then
	echo "!! The 'pear' command was not found on this system."
	echo ""
	exit 1
fi

# If no args provided, try reading the config file.
if [ -z "$1" ]; then
	if [ -s "$PEAR_PACKAGES_FILE" ]; then
		echo "## Loading channels/packages from '$PEAR_PACKAGES_FILE'."
		mapfile -t ARGS < <( cat "$PEAR_PACKAGES_FILE" )
	else
		echo "!! No arguments provided, and no/empty config file at '$PEAR_PACKAGES_FILE'."
		echo ""
		exit 2
	fi
else
	ARGS=$@
fi

## Define accumulators for channel list and package list.
CHANNELS=()
PACKAGES=()

## Compile channels and packages into their own lists.
for ARG in "${ARGS[@]}"; do
	IFS=":" read -a PAIR <<< "$ARG"
	if [ "${PAIR[1]+isset}" ]; then
		CHANNELS+=(${PAIR[0]})
		PACKAGES+=(${PAIR[1]})
	else
		PACKAGES+=(${PAIR[0]})
	fi
done

# Remove duplicates from each list.
CHANNELS=($(printf "%s\n" "${CHANNELS[@]}" | sort -u))
PACKAGES=($(printf "%s\n" "${PACKAGES[@]}" | sort -u))

# Discover all channels, if any, then update them.
if [ "${#CHANNELS[@]}" -gt 0 ]; then
	echo "## ${#CHANNELS[@]} channels to discover: ${CHANNELS[@]}"
	for CHANNEL in "${CHANNELS[@]}"; do
		echo "## Discovering '$CHANNEL'"
		"$PEAR" channel-discover $CHANNEL
	done

	echo "## Updating channels."
	"$PEAR" update-channels
fi

# Install all packages. If any of these fail, the whole script has "failed".
if [ "${#PACKAGES[@]}" -gt 0 ]; then
	echo "## ${#PACKAGES[@]} packages to install: ${PACKAGES[@]}"
	for PACKAGE in "${PACKAGES[@]}"; do
		get_channel_for_package $PACKAGE  # Sets $CHANNEL
		if "$THIS_DIR/pear-package-installed-dumb" "$PACKAGE" "$CHANNEL"; then
			echo "## Package '$PACKAGE' seems to already be installed. Skipping."
			continue
		else
			echo "## Installing '$PACKAGE'"
			"$PEAR" install $PEAR_OPTIONS "$PACKAGE"
		fi
	done
fi
echo "## PEAR installations complete."
