#!/usr/bin/env php
<?php
// Usage: In another bash script, do this:
//   eval $( bin/db-credentials.sh )
//
// This will populate bash variables for DB_HOST, DB_DATABASE, DB_LOGIN
// and DB_PASSWORD. See `db-login` for a usage pattern that preserves
// special char escaping for DB_PASS.
//
// Attempts to obtain the current `::$default` database connection
// settings from the Cake app's Config/database.php file. There are 3
// cases to handle:
//
//   1. database.php is just a loader for `Configure::read('Database')`
//      and the ConfigRead plugin is installed. We can obtain the values
//      from a call to `bin/cake config_read.config_read -b Database.default`.
//   2. database.php is just a loader, but ConfigRead is not available. We
//      have to "fake" the `Configure` and `Cache` classes to be able to
//      include `Config/core.php` directly.
//   3. database.php uses the "stock" configuration, so we can include
//      `Config/database.php` directly.
//
//   Ref: http://stackoverflow.com/questions/16320858


// Try using ConfigReadShell first, if it's available.
try {
	$db = new DbConfig();
	printDbConfig($db);
	exit(0);
} catch (Exception $e) {}

// Fallback (standard) approach.
$dbConfigFile = getcwd() . '/Config/database.php';
if ((include $dbConfigFile)) {
	$db = new DATABASE_CONFIG();
	printDbConfig($db);
}

// Outright failure case.
else {
	exit(2);
}


//----------
function printDbConfig($db) {
	echo <<<EOD
DB_HOST='{$db->default['host']}'
DB_DATABASE='{$db->default['database']}'
DB_LOGIN='{$db->default['login']}'
DB_PASSWORD='{$db->default['password']}'
EOD;
}

//----------
class DbConfig {
	public $default = array();
	public function __construct() {
		$dir = getcwd();
		$cmd = escapeshellcmd("{$dir}/bin/cake config_read.config_read -b Database.default");
		$response = array();
		$code = 0;
		exec($cmd, $response, $code);

		if (empty($response) || $code > 0) {
			throw new RuntimeException('Unable to fetch Database config from ConfigReadShell.');
		}

		foreach ($response as $line) {
			if (!substr_count($line, '=')) {
				continue;
			}
			list($key, $val) = explode('=', $line, 2);
			$key = strtolower(str_replace('DATABASE_DEFAULT_', '', $key));
			$val = substr($val, 1, -1);
			$this->default[$key] = $val;
		}

		if (empty($this->default)) {
			throw new RuntimeException('No Database config found in Configure.');
		}
	}
}

//----------
class Configure {
	public static $storage = array();
	public static function write($key, $value) {
		$sub = array();
		$ptr = &$sub;
		foreach (explode('.', $key) as $part) {
			$ptr[$part] = array();
			$ptr = &$ptr[$part];
		}
		$ptr = $value;
		self::$storage = self::merge(self::$storage, $sub);
	}
	public static function read($key) {
		$sub = self::$storage;
		if (substr_count($key, '.')) {
			foreach (explode('.', $key) as $part) {
				$sub = $sub[$part];
			}
		}
		return $sub;
	}
	public static function load($file) {
		if (!(include "Config/{$file}.php")) {
			return false;
		}
		self::$storage = self::merge(self::$storage, $config);
	}
	//Ref: http://api.cakephp.org/2.5/source-class-Hash.html#661-700
	public static function merge(array $data, $merge) {
		$args = array_slice(func_get_args(), 1);
		$return = $data;

		foreach ($args as &$curArg) {
			$stack[] = array((array)$curArg, &$return);
		}
		unset($curArg);

		while (!empty($stack)) {
			foreach ($stack as $curKey => &$curMerge) {
				foreach ($curMerge[0] as $key => &$val) {
					if (!empty($curMerge[1][$key]) && (array)$curMerge[1][$key] === $curMerge[1][$key] && (array)$val === $val) {
						$stack[] = array(&$val, &$curMerge[1][$key]);
					} elseif ((int)$key === $key && isset($curMerge[1][$key])) {
						$curMerge[1][] = $val;
					} else {
						$curMerge[1][$key] = $val;
					}
				}
				unset($stack[$curKey]);
			}
 			unset($curMerge);
		}
		return $return;
	}
}

//----------
class Cache {
	public static function config($key, $value) {
		// Completely ignore this.
	}
}
